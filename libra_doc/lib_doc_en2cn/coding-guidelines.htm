<!DOCTYPE html>
<html lang="en">

<head>
  <meta charSet="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Coding Guidelines · Libra</title>
  <meta name="viewport" content="width=device-width" />
  <meta name="generator" content="Docusaurus" />
  <meta name="description" content="This document describes the coding guidelines for the Libra Core Rust codebase." />
  <meta name="docsearch:language" content="en" />
  <meta property="og:title" content="Coding Guidelines · Libra" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://developers.libra.org/" />
  <meta property="og:description"
    content="This document describes the coding guidelines for the Libra Core Rust codebase." />
  <meta property="og:image" content="https://developers.libra.org/img/libra.png" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:image" content="https://developers.libra.org/img/libra.png" />
  <link rel="shortcut icon" href="libra.ico" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" />
  <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Libra Blog ATOM Feed" />
  <link rel="alternate" type="application/rss+xml" href="feed.xml" title="Libra Blog RSS Feed" />
  <script type="text/javascript" src="buttons.js"></script>
  <script type="text/javascript" src="code_block_buttons.js"></script>
  <script type="text/javascript" src="cookie_banner.js"></script>
  <script type="text/javascript" src="disable_adblock.js"></script>
  <script type="text/javascript" src="segment.analytics.min.js"></script>
  <script type="text/javascript" src="segment.js"></script>
  <script type="text/javascript" src="clipboardjs.2.0.0.min.js"></script>
  <script type="text/javascript" src="forms.js"></script>
  <script src="scrollSpy.js"></script>
  <link rel="stylesheet" href="main.css" />
  <script src="codetabs.js"></script>
</head>

<body class="sideNavVisible separateOnPageNav">
  <div class="fixedHeaderContainer">
    <div class="headerWrapper wrapper">
      <header><a href="https://developers.libra.org/"><img class="logo" src="libra-nav-logo.png" alt="Libra" />
          <h2 class="headerTitleWithLogo">Libra</h2>
        </a>
        <div class="navigationWrapper navigationSlider">
          <nav class="slidingNav">
            <ul class="nav-site nav-site-internal">
              <li class=""><a href="https://violas.io/">主页</a></li>
              <li class="siteNavGroupActive"><a href="welcome-to-libra.htm" target="_self">文档</a></li>
              <li class=""><a href="https://community.libra.org" target="_self">Libra 社区</a></li>
              <li class=""><a href="blog_2.html" target="_self">Libra Blog</a></li>
              <li class=""><a href="https://libra.org" target="_self">libra 官网</a></li>
              <li class=""><a href="https://github.com/libra/libra" target="_self">Libra GitHub</a></li>
              <li class=""><a href="../lib_doc_en/coding-guidelines.htm">中/EN</a></li>
              <li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react"
                  placeholder="Search" title="Search" /></li>
            </ul>
          </nav>
        </div>
      </header>
    </div>
  </div>
  <div class="navPusher">
    <div class="docMainWrapper wrapper">
      <div class="docsNavContainer" id="docsNav">
        <nav class="toc">
          <div class="toggleNav">
            <section class="navWrapper wrapper">
              <div class="navBreadcrumb wrapper">
                <div class="navToggle" id="navToggler">
                  <div class="hamburger-menu">
                    <div class="line1"></div>
                    <div class="line2"></div>
                    <div class="line3"></div>
                  </div>
                </div>
                <h2><i>›</i><span>学习 Libra</span></h2>
                <div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div>
              </div>
              <div class="navGroups">
                <div class="navGroup">
                  <h3 class="navGroupCategoryTitle">学习 Libra</h3>
                  <ul class="">
                    <li class="navListItem"><a class="navItem" href="welcome-to-libra.htm">欢迎</a>
                    </li>
                    <li class="navListItem"><a class="navItem" href="libra-protocol.htm">Libra 协议: 核心概念</a></li>
                    <li class="navListItem"><a class="navItem" href="life-of-a-transaction.htm">交易的生命周期</a></li>
                    <div class="navGroup subNavGroup">
                      <h4 class="navGroupSubcategoryTitle">技术论文</h4>
                      <ul>
                        <li class="navListItem"><a class="navItem" href="the-libra-blockchain-paper.htm">Libra 区块链</a>
                        </li>
                        <li class="navListItem"><a class="navItem" href="move-paper.htm">Move: 一种可编程资源的语言</a></li>
                        <li class="navListItem"><a class="navItem"
                            href="state-machine-replication-paper.htm">Libra区块链中状态机的复制</a></li>
                      </ul>
                    </div>
                  </ul>
                </div>
                <div class="navGroup">
                  <h3 class="navGroupCategoryTitle">学习Libra核心</h3>
                  <ul class="">
                    <li class="navListItem"><a class="navItem" href="my-first-transaction.htm">我的第一笔交易</a>
                    </li>
                    <li class="navListItem"><a class="navItem" href="move-overview.htm">Move概述</a>
                    </li>
                    <li class="navListItem"><a class="navItem" href="run-local-network.htm">在本地网络上运行</a></li>
                    <li class="navListItem"><a class="navItem" href="run-move-locally.htm">本地运行Move程序</a>
                    </li>
                  </ul>
                </div>
                <div class="navGroup">
                  <h3 class="navGroupCategoryTitle">社区</h3>
                  <ul class="">
                    <li class="navListItem"><a class="navItem" href="libra-open-source-paper.htm">Libra开源</a>
                    </li>
                    <li class="navListItem"><a class="navItem" href="contributing.htm">贡献指南</a></li>
                    <li class="navListItem navListItemActive"><a class="navItem" href="coding-guidelines.htm">代码指南</a>
                    </li>
                    <li class="navListItem"><a class="navItem" href="security.htm">报告漏洞</a></li>
                  </ul>
                </div>
                <div class="navGroup">
                  <h3 class="navGroupCategoryTitle">Libra 协议实现</h3>
                  <ul class="">
                    <li class="navListItem"><a class="navItem" href="libra-core-overview.htm">Libra Core概述</a>
                    </li>
                    <div class="navGroup subNavGroup">
                      <h4 class="navGroupSubcategoryTitle">READMEs</h4>
                      <ul>
                        <li class="navListItem"><a class="navItem" href="admission-control.htm">准入控制 admission
                            control</a>
                        </li>
                        <li class="navListItem"><a class="navItem" href="bytecode-verifier.htm">字节码验证器 Bytecode
                            Verifier</a>
                        </li>
                        <li class="navListItem"><a class="navItem" href="consensus.htm">共识组件 Consensus</a></li>
                        <li class="navListItem"><a class="navItem" href="crypto.htm">加密组件 Crypto</a></li>
                        <li class="navListItem"><a class="navItem" href="execution.htm">执行组件 Execution</a></li>
                        <li class="navListItem"><a class="navItem" href="mempool.htm">内存池 Mempool</a></li>
                        <li class="navListItem"><a class="navItem" href="ir-to-bytecode.htm">Move IR 编译器</a></li>
                        <li class="navListItem"><a class="navItem" href="move-language.htm">Move 语言</a></li>
                        <li class="navListItem"><a class="navItem" href="network.htm">网络组件 Network</a></li>
                        <li class="navListItem"><a class="navItem" href="storage.htm">存储组件 Storage</a></li>
                        <li class="navListItem"><a class="navItem" href="vm.htm">虚拟机 Virtual Machine</a></li>
                      </ul>
                    </div>
                  </ul>
                </div>
                <div class="navGroup">
                  <h3 class="navGroupCategoryTitle">参考引用</h3>
                  <ul class="">
                    <li class="navListItem"><a class="navItem" href="libra-cli.htm">Libra命令行工具</a></li>
                    <li class="navListItem"><a class="navItem" href="glossary.htm">词汇表</a></li>
                  </ul>
                </div>
              </div>
            </section>
          </div>
          <script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory) {
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')) {
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function () {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function () {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function (event) {
                var el = event.target;
                while (el !== headings) {
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else {
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function (event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
          </script>
        </nav>
      </div>
      <div class="container mainContainer">
        <div class="wrapper">
          <div class="post">
            <header class="postHeader"><a class="edit-page-link button"
                href="https://github.com/lbc-team/libra-docs/edit/lbc/docs/community/coding-guidelines.md"
                target="_blank" rel="noreferrer noopener">Edit</a>
              <h1 class="postHeaderTitle">代码指南</h1>
            </header>
            <article>
              <div><span>
                  <p>文档描述了Libra Core Rust代码库的编码指南。</p>
                  <h2><a class="anchor" aria-hidden="true" id="code-formatting"></a><a href="#code-formatting"
                      aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16"
                        version="1.1" viewBox="0 0 16 16" width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>代码格式化</h2>
                  <p>所有的代码格式都是使用了项目的特定配置的 <a
                      href="https://github.com/rust-lang/rustfmt">rustfmt</a>来实现的。下面是一个运行<code>rustfmt</code>并遵守项目约定的简单命令：
                  </p>
                  <pre><code class="hljs">libra$ cargo fmt
</code></pre>
                  <h2><a class="anchor" aria-hidden="true" id="code-analysis"></a><a href="#code-analysis"
                      aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16"
                        version="1.1" viewBox="0 0 16 16" width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>代码分析</h2>
                  <p><a href="https://github.com/rust-lang/rust-clippy">Clippy</a>
                    用于捕捉常见错误，并作为持续集成的一部分运行。在提交您的代码进行审查之前，您可以使用我们的配置运行clippy：</p>
                  <pre><code class="hljs">libra$ ./scripts/clippy.sh
</code></pre>
                  <p>一般来说，我们遵循<a
                      href="https://rust-lang-nursery.github.io/api-guidelines/about.html">rust-lang-nursery</a>的提议。本指南的其余部分提供了有关特定主题的详细指南，以实现代码库的一致性。
                  </p>
                  <h2><a class="anchor" aria-hidden="true" id="code-documentation"></a><a href="#code-documentation"
                      aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16"
                        version="1.1" viewBox="0 0 16 16" width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>代码文档</h2>
                  <p>任何共有属性fields，函数和方法应该使用<a
                      href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments">Rustdoc</a>生成文档。
                    对于模块、结构、枚举和函数请遵循下面的详细约定。当导航Rustdoc，单行<em>[single line]</em>用作预览。示例请参阅Rustdoc <a
                      href="https://doc.rust-lang.org/std/collections/index.html">collections</a>中“结构Structs”和“枚举enums”部分。
                  </p>
                  <pre><code class="hljs css language-rust"><span class="hljs-comment">/// [Single line] One line summary description</span>
<span class="hljs-comment">///</span>
<span class="hljs-comment">/// [Longer description] Multiple lines, inline code </span>
<span class="hljs-comment">/// examples, invariants, purpose, usage, etc. </span>
[Attributes] If attributes exist, add after Rustdoc
</code></pre>
                  <p>下面示例：</p>
                  <pre><code class="hljs css language-rust"><span class="hljs-comment">/// Represents (x, y) of a 2-dimensional grid</span>
<span class="hljs-comment">///</span>
<span class="hljs-comment">/// A line is defined by 2 instances.</span>
<span class="hljs-comment">/// A plane is defined by 3 instances.</span>
<span class="hljs-meta">#[repr(C)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> {
  x: <span class="hljs-built_in">i32</span>,
  y: <span class="hljs-built_in">i32</span>,
}
</code></pre>
                  <h3><a class="anchor" aria-hidden="true" id="constants-and-fields"></a><a href="#constants-and-fields"
                      aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16"
                        version="1.1" viewBox="0 0 16 16" width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>常量和字段</h3>
                  <p>描述此数据的目的和定义。</p>
                  <h3><a class="anchor" aria-hidden="true" id="functions-and-methods"></a><a
                      href="#functions-and-methods" aria-hidden="true" class="hash-link"><svg class="hash-link-icon"
                        aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>函数和方法</h3>
                  <p>为每个函数记录以下内容:</p>
                  <ul>
                    <li>方法执行的操作——“该方法将一笔新交易加到mempool。”使用主动语态和现在时。</li>
                    <li>描述如何和为什么使用这个方法</li>
                    <li>调用方法之前必须满足的任何条件</li>
                    <li>在什么状态条件下函数会panic!()或返回Error</li>
                    <li>返回值的简要说明</li>
                    <li>其他特殊行为说明</li>
                  </ul>
                  <h3><a class="anchor" aria-hidden="true"
                      id="readmemd-for-top-level-directories-and-other-major-components"></a><a
                      href="#readmemd-for-top-level-directories-and-other-major-components" aria-hidden="true"
                      class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1"
                        viewBox="0 0 16 16" width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>根目录的README和其他主要组件
                  </h3>
                  <p>Libra Core每个主要组件都需要一个<code>README.md</code>文件。主要组件包括： </p>
                  <ul>
                    <li>根目录(如 <code>libra/network</code>, <code>libra/language</code>).</li>
                    <li>系统中最主要的crates(如 <code>vm_runtime</code>).
                    </li>
                  </ul>
                  <p>README.md 文件应该包含：</p>
                  <ul>
                    <li>组件的概念性文档</li>
                    <li>组件的外部API文档的链接。</li>
                  </ul>
                  <p>你可以查看示例README文件 <code>libra/network/README.md</code>，该文件描述了网络建立</p>
                  <p>README.md的模板如下:</p>
                  <pre><code class="hljs css language-markdown"><span class="hljs-section"># Component Name</span>

[Summary line: Start with one sentence about this component.]

<span class="hljs-section">## Overview</span>
<span class="hljs-bullet">
* </span>Describe the purpose of this component and how the code in this directory works.
<span class="hljs-bullet">* </span>Describe the interaction of code in this directory with other components.
<span class="hljs-bullet">* </span>Describe the security model and assumptions about the crates in this directory. 

<span class="hljs-section">## Implementation Details</span>
<span class="hljs-bullet">
* </span>Describe how the component is modeled. For example, why is the code organized the way it is?
<span class="hljs-bullet">* </span>Other relevant implementation details.

<span class="hljs-section">## API Documentation</span>

For the external API of this crate refer to the API documentation.

For a top-level directory, link to the most important APIs within. 

</code></pre>
                  <h2><a class="anchor" aria-hidden="true" id="code-suggestions"></a><a href="#code-suggestions"
                      aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16"
                        version="1.1" viewBox="0 0 16 16" width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>编码建议</h2>
                  <p>在下面的小节中，我们为一致的代码库提出了一些最佳实践。我们将研究和识别可以使用clippy实施的实践。这些信息将随着时间的推移而发展和改善。</p>
                  <h3><a class="anchor" aria-hidden="true" id="attributes"></a><a href="#attributes" aria-hidden="true"
                      class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1"
                        viewBox="0 0 16 16" width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>属性</h3>
                  <p>确保使用适当的属性来处理死代码：</p>
                  <pre><code class="hljs css language-rust"><span class="hljs-comment">// For code that is intended for production usage in the future</span>
<span class="hljs-meta">#[allow(dead_code)]</span>
<span class="hljs-comment">// For code that is only intended for testing and </span>
<span class="hljs-comment">// has no intended production use</span>
<span class="hljs-meta">#[cfg(test)]</span>
</code></pre>
                  <h3><a class="anchor" aria-hidden="true" id="avoid-deref-polymorphism"></a><a
                      href="#avoid-deref-polymorphism" aria-hidden="true" class="hash-link"><svg class="hash-link-icon"
                        aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>避免Deref多态</h3>
                  <p>不要滥用Deref特性来模拟结构之间的继承，从而重用方法。有关详细信息，请阅读 <a
                      href="https://github.com/rust-unofficial/patterns/blob/master/anti_patterns/deref.md">here</a>.
                  </p>
                  <h3><a class="anchor" aria-hidden="true" id="comments"></a><a href="#comments" aria-hidden="true"
                      class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1"
                        viewBox="0 0 16 16" width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>注释</h3>
                  <p>为了一致和simpler grepping，我们建议您使用 <code>//</code> 和 <code>///</code>注释，而不是块注释 <code>/* ... */</code>。
                  </p>
                  <h3><a class="anchor" aria-hidden="true" id="cloning"></a><a href="#cloning" aria-hidden="true"
                      class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1"
                        viewBox="0 0 16 16" width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>克隆</h3>
                  <p>如果<code>x</code>是引用计数，请选择<a
                      href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc::clone(x)</code></a> 而不是
                    <code>x.clone().</code>Arc::clone(x) 显式地表示我们正在克隆<code>x</code>。这避免了我们是执行<code>结构体</code>,
                    <code>枚举,</code> 其他类型的昂贵克隆，还是只执行廉价的引用副本的困惑。</p>
                  <p>此外，如果要传递<a
                      href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a>类型，请考虑使用新的类型包装器：
                  </p>
                  <pre><code class="hljs css language-rust"><span class="hljs-meta">#[derive(Clone, Debug)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span>(Arc&lt;FooInner&gt;);
</code></pre>
                  <h3><a class="anchor" aria-hidden="true" id="concurrent-types"></a><a href="#concurrent-types"
                      aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16"
                        version="1.1" viewBox="0 0 16 16" width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>并发类型</h3>
                  <p>并发类型如<a href="https://docs.rs/crate/chashmap"><code>CHashMap</code></a>, <a
                      href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicUsize.html"><code>AtomicUsize</code></a>等为了支持内部转换方法的并发访问，有一个对自身不可改变的引用，如
                    <code>fn foo_mut(&amp;self,...)</code> 。好的实践（像示例中提到的这些）是避免在外部暴露同步原语(如<code>Mutex</code>,
                    <code>RwLock</code>) 并清楚地记录方法语义和不变量。
                  </p>
                  <p><strong>什么时候使用通道(_channels)_与并发类型(concurrent types)？</strong></p>
                  <p>下面列出的是基于经验的高级建议：</p>
                  <ul>
                    <li>
                      <p>
                        通道(Channels)用于所有权转移、类型分离和粗粒度消息。它们非常适合于传输数据的所有权、分发工作单元和异步结果通知。此外，它们有助于打破循环依赖(例如，<code>struct Foo</code>
                        包含一个 <code>Arc&lt;Bar&gt;</code> ，
                        <code>struct Bar</code> 包含一个<code>Arc&lt;Foo&gt;</code> 会导致复杂的初始化).</p>
                    </li>
                    <li>
                      <p>并发类型(Concurrent types) (如 <a href="https://docs.rs/crate/chashmap"><code>CHashMap</code></a>或在
                        <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>,
                        <a
                          href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock</code></a>,等上构建内部可变的结构体)更适合于缓存和状态。
                      </p>
                    </li>
                  </ul>
                  <h3><a class="anchor" aria-hidden="true" id="error-handling"></a><a href="#error-handling"
                      aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16"
                        version="1.1" viewBox="0 0 16 16" width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>错误处理</h3>
                  <p>错误处理建议遵循 <a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">Rust book
                      guidance</a>。Rust将错误分为两大类：可恢复的和不可恢复的错误。应使用 <a
                      href="https://doc.rust-lang.org/std/result/">Result</a>处理可恢复的错误。我们对不可恢复错误的建议如下：</p>
                  <p><strong>Panic</strong></p>
                  <ul>
                    <li><code>panic!()</code> - Runtime panic! 仅当结果状态无法继续处理时才应使用。它不能用于任何可恢复的错误。</li>
                    <li><code>unwrap()</code> - Unwrap 只能用于mutexes (例如
                      <code>lock().unwrap()</code>)和测试代码。对于所有其他用例，首选
                      <code>expect()</code>。唯一的例外是如果错误消息是自定义生成的，在这种情况下使用
                      <code>.unwrap_or_else(|| panic!(&quot;error: {}&quot;, foo))</code></li>
                    <li><code>expect()</code> - Expect应在系统预留的不变量时调用。expect() 优先于 unwrap()，并且在大多数情况下都应该包含失败时的详细错误消息。.
                    </li>
                    <li><code>assert!()</code> - 这个宏保存在debug/release中，必要时应该用来保护系统的不变量。</li>
                    <li><code>unreachable!()</code> - 此宏将在不可达（违反不变量）的代码上死机，可在适当的情况下使用。
                    </li>
                  </ul>
                  <h3><a class="anchor" aria-hidden="true" id="generics"></a><a href="#generics" aria-hidden="true"
                      class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1"
                        viewBox="0 0 16 16" width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>泛型</h3>
                  <p>泛型允许静态调度的动态行为（类似于 <a
                      href="https://doc.rust-lang.org/book/ch10-02-traits.html"><code>trait</code></a>方法）。随着泛型类型参数数量的增加，使用类型/方法的难度也随之增加（例如，考虑此类型所需的特征边界的组合、相关类型上的重复特征边界等）。为了避免这种复杂性，我们通常尽量避免使用大量泛型类型参数。我们发现，使用动态调度将具有大量泛型对象的代码转换为trait对象通常会简化我们的代码。
                  </p>
                  <h3><a class="anchor" aria-hidden="true" id="getters-and-setters"></a><a href="#getters-and-setters"
                      aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16"
                        version="1.1" viewBox="0 0 16 16" width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>Getters and Setters</h3>
                  <p>除了测试代码，尽可能将字段可见性设置为private。私有字段允许构造函数强制使用内部不变量。为调用者可能需要的数据实现getters，除非需要可变状态否则避免使用setter。</p>
                  <p>公共字段最适合C风格的 <a href="https://doc.rust-lang.org/book/ch05-00-structs.html"><code>struct</code></a>
                    类型：没有内部不变量的复合被动数据结构。命名建议遵循<a
                      href="https://rust-lang-nursery.github.io/api-guidelines/naming.html#getter-names-follow-rust-convention-c-getter">指南，</a>
                    示例如下。</p>
                  <pre><code class="hljs css language-rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span> {
  size: <span class="hljs-built_in">usize</span>,
  key_to_value: HashMap&lt;<span class="hljs-built_in">u32</span>, <span class="hljs-built_in">u32</span>&gt;
}

<span class="hljs-keyword">impl</span> Foo {
  <span class="hljs-comment">/// Return a copy when inexpensive</span>
  <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">size</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">usize</span> {
      <span class="hljs-keyword">self</span>.size
  }

  <span class="hljs-comment">/// Borrow for expensive copies</span>
  <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">key_to_value</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;HashMap&lt;<span class="hljs-built_in">u32</span>, <span class="hljs-built_in">u32</span>&gt; {
      &amp;<span class="hljs-keyword">self</span>.key_to_value
  }

  <span class="hljs-comment">/// Setter follows set_xxx pattern</span>
  <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_foo</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, size: <span class="hljs-built_in">usize</span>){
      <span class="hljs-keyword">self</span>.size = size;
  }

  <span class="hljs-comment">/// For a more complex getter, using get_XXX is acceptable </span>
  <span class="hljs-comment">/// (similar to HashMap) with well-defined and </span>
  <span class="hljs-comment">/// commented semantics</span>
  <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_value</span></span>(&amp;<span class="hljs-keyword">self</span>, key: <span class="hljs-built_in">u32</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;&amp;<span class="hljs-built_in">u32</span>&gt; {
      <span class="hljs-keyword">self</span>.key_to_value.get(&amp;key)
  }
}
</code></pre>
                  <h3><a class="anchor" aria-hidden="true" id="logging"></a><a href="#logging" aria-hidden="true"
                      class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1"
                        viewBox="0 0 16 16" width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>日志</h3>
                  <p>我们目前使用 <a href="https://docs.rs/slog/">slog</a>记录日志。</p>
                  <ul>
                    <li><a href="https://docs.rs/slog/2.4.1/slog/macro.error.html">error!</a> -
                      错误级别的消息在 <a href="https://docs.rs/slog/">slog</a>中具有最高的紧急性。出现意外错误（例如，超过了完成 RPC
                      的最大重试次数或无法将数据存储到本地存储）。</li>
                    <li><a href="https://docs.rs/slog/2.4.1/slog/macro.warn.html">warn!</a> -
                      警告级别的消息有助于通知管理员自动处理的问题（例如，重试失败的网络连接或多次接收同一消息等）。</li>
                    <li><a href="https://docs.rs/slog/2.4.1/slog/macro.info.html">info!</a> -
                      信息级消息非常适合“一次性”事件（例如一次性启动和关闭时的日志状态）或不经常发生的周期性事件（例如每天更改验证程序集）。</li>
                    <li><a href="https://docs.rs/slog/2.4.1/slog/macro.debug.html">debug!</a> -
                      调试级消息可以频繁地发生（即，潜在地每秒大于 1个消息），并且通常不期望在生产中启用。</li>
                    <li><a href="https://docs.rs/slog/2.4.1/slog/macro.trace.html">trace!</a> -
                      跟踪级日志记录通常仅用于函数进入/退出。</li>
                  </ul>
                  <h3><a class="anchor" aria-hidden="true" id="testing"></a><a href="#testing" aria-hidden="true"
                      class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1"
                        viewBox="0 0 16 16" width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>测试</h3>
                  <h3><a class="anchor" aria-hidden="true" id="testing"></a><a href="coding-guidelines.htm#testing"
                      aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16"
                        version="1.1" viewBox="0 0 16 16" width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>测试</h3>
                  <p><em>单元测试</em></p>
                  <p>理想情况下，所有代码都应该进行单元测试。单元测试文件应该与<code>mod.rs</code> 位于同一目录中，并且它们的文件名应该以 <code>_test.rs</code>结尾。要测试的模块应该用<code>#[cfg(test)]</code>注释测试模块。例如，如果crate有一个数据库模块，则预期的目录结构如下：</p>
                  <pre><code class="hljs">src/db                        -&gt; directory of db module
  src/db/mod.rs                 -&gt; code of db module
  src/db/read_test.rs           -&gt; db test 1
  src/db/write_test.rs          -&gt; db test 2
  src/db/access/mod.rs          -&gt; directory of access submodule
  src/db/access/access_test.rs  -&gt; test of access submodule
  </code></pre>
                  <p><em>基于属性的测试</em></p>
                  <p>Libra 包含使用<a href="https://github.com/AltSysrq/proptest"><code>proptest</code> 框架</a>用Rust编写的<a href="https://blog.jessitron.com/2013/04/25/property-based-testing-what-is-it/">property-based tests</a> 。基于属性的测试生成随机测试用例，并断言被测代码的不变量（也称为_属性<em>properties</em>）。</p>
                  <p>Libra中测试properties的一些示例：</p>
                  <ul>
                    <li>使用序列化程序的随机输入测试每个序列化和反序列化对的正确性。任何一对互逆的函数都可以通过这种方式进行测试。</li>
                    <li>通过VM执行公共交易的结果使用随机生成的场景进行测试，并通过<em>oracle</em>进行验证。</li>
                  </ul>
                  <p><code>proptest</code>教程可以在 <a href="https://altsysrq.github.io/proptest-book/proptest/getting-started.html"><code>proptest</code> </a>书中找到。</p>
                  <p>参考资料：</p>
                  <ul>
                    <li><a href="https://hypothesis.works/articles/what-is-property-based-testing/">What is Property
                        Based Testing?</a> (包含与fuzzing的比较)</li>
                    <li><a href="https://fsharpforfunandprofit.com/posts/property-based-testing/">An introduction to
                        property-based testing</a></li>
                    <li><a href="https://fsharpforfunandprofit.com/posts/property-based-testing-2/">Choosing properties
                        for property-based testing</a></li>
                  </ul>
                  <p><em>条件编译测试</em></p>
                  <p>Libra 的<a href="https://doc.rust-lang.org/stable/reference/conditional-compilation.html">conditionally
                      compiles</a> 代码只与测试相关，但不包含测试（unitary或其他）。这方面的例子包括proptest策略、特定特性的实现和派生（例如，偶尔的<code>Clone</code>）、helper函数等。由于Cargo <a href="https://github.com/rust-lang/cargo/issues/2911">目前不适合激活基准中的特性</a>,因此我们依赖两个条件来执行此条件编译：</p>
                  <ul>
                    <li>测试标志(test flag)，由与条件测试专用代码位于同一crate中的依赖测试代码激活。</li>
                    <li>“测试(testing)”自定义功能，由作为条件测试专用代码的其他crate中的依赖测试代码激活（如下所示）。</li>
                  </ul>
                  <p>因此，推荐您按照以下方式设置专用测试代码。例如，我们将认为您在<code>foo_crate</code>中定义一个测试专用的helper函数<code>foo</code> ：</p>
                  <ol>
                    <li>在<code>foo_crate/Cargo.toml</code>中定义“testing”标志，并将其设为非默认值：
                      <pre><code class="hljs">[features]
  default = []
  testing = []
  </code></pre>
                    </li>
                    <li>使用测试标志（用于in-crate调用方）和“testing”自定义功能（用于out-of-crate调用方）为您的测试专用<code>helper foo</code>添加注解
                      <pre><code class="hljs">#[cfg(any(test, feature = "testing"))]
  fn foo() { ... }
  </code></pre>
                    </li>
                    <li>将激活“testing”功能的开发依赖项添加到只导入这个测试专用成员的<code>crates</code>中：
                      <pre><code class="hljs">[dev-dependencies.foo_crate]
  path = { "&lt;same as the one in [dependencies]&gt;"}
  features = ["testing"]
  </code></pre>
                    </li>
                    <li>（可选）使用 <code>cfg_attr </code>使测试专用特性派生成为条件：
                      <pre><code class="hljs">#[cfg_attr(any(test, feature = "testing"), derive(FooTrait))]
  #[derive(Debug, Display, ...)] // inconditional derivations
  struct Foo { ... }
  </code></pre>
                    </li>
                    <li>（可选）为调用仅包含测试成员的<code>crates</code>的<code>crates</code>设置功能传递性。假设是<code>bar_crate</code>   的情况，它通过其测试<code>helpers</code>调用<code>foo_crate</code>  来使用您的测试专用<code>Foo</code>。下面是如何设置 <code>bar_crate/Cargo.toml</code>
                      <pre><code class="hljs">[features]
  default = []
  testing = ["foo_crate/testing"]
  </code></pre>
                    </li>
                  </ol>
                  <p><em>集成测试_ integration tests_的最后一个注意事项</em>: 所有在另一个crate中使用条件测试专用元素的测试都需要通过中的<code>[features]</code>部分激活“testing”功能。 <a href="https://doc.rust-lang.org/rust-by-example/testing/integration_testing.html">集成测试</a> 既不能依赖于 <code>test</code> 标志，也不能有适当的<code>Cargo.toml</code> 去激活特性。因此，在Libra 代码库中，我们建议将依赖于测试专用代码的集成测试提取到它们自己的crate中。您可以在<code>language/vm/serializer_tests</code>  查看这种提取集成测试的示例。</p>
                  <p><em>开发人员注意：</em>: 我们使用特性重新导出（在 <code>Cargo.toml</code>的<code>[features]</code>部分中）的原因是配置文件不足以激活"testing"特性标志。详见 <a
                      href="https://github.com/rust-lang/cargo/issues/2911">cargo-issue #291</a> </p>
                  <p><em>模糊测试</em></p>
                  <p>Libra包含用于模糊崩溃代码（如反序列化程序）的保护带，可以通过 <a
                      href="https://rust-fuzz.github.io/book/cargo-fuzz.html"><code>cargo fuzz</code></a>使用<a
                      href="https://llvm.org/docs/LibFuzzer.html"><code>libFuzzer</code></a>引入。有关更多示例，请参见<code>testsuite/libra_fuzzer</code> 目录。</p>
                </span></div>
            </article>
          </div>
          <div class="docs-prevnext"><a class="docs-prev button" href="contributing.htm"><span
                class="arrow-prev">←
              </span><span>贡献指南</span></a><a class="docs-next button"
              href="security.htm"><span>报告漏洞</span><span class="arrow-next">
                →</span></a></div>
        </div>
      </div>
      <nav class="onPageNav">
        <ul class="toc-headings">
          <li><a href="#code-formatting">代码格式化</a></li>
          <li><a href="#code-analysis">代码分析</a></li>
          <li><a href="#code-documentation">代码文档</a>
            <ul class="toc-headings">
              <li><a href="#constants-and-fields">常量和字段</a></li>
              <li><a href="#functions-and-methods">函数和方法</a></li>
              <li><a href="#readmemd-for-top-level-directories-and-other-major-components">根目录的README和其他主要组件</a></li>
            </ul>
          </li>
          <li><a href="#code-suggestions">编码建议</a>
            <ul class="toc-headings">
              <li><a href="#attributes">属性</a></li>
              <li><a href="#avoid-deref-polymorphism">避免Deref多态</a></li>
              <li><a href="#comments">注释</a></li>
              <li><a href="#cloning">克隆</a></li>
              <li><a href="#concurrent-types">并发类型</a></li>
              <li><a href="#error-handling">错误处理</a></li>
              <li><a href="#generics">泛型</a></li>
              <li><a href="#getters-and-setters">Getters and Setters</a></li>
              <li><a href="#logging">日志</a></li>
              <li><a href="#testing">测试</a></li>
            </ul>
          </li>
        </ul>
      </nav>
    </div>
    <footer class="nav-footer" id="footer">
        <section class="sitemap"><a href="https://developers.libra.org/" class="nav-home"><img
              src="libra-logomark-white.png" alt="Libra" /></a>
          <div class="footerSection">
            <h5>Learn About Libra</h5><a href="welcome-to-libra.htm">Welcome to Libra</a><a
              href="libra-protocol.htm">Libra Protocol</a><a href="the-libra-blockchain-paper.htm">Libra Blockchain</a><a
              href="life-of-a-transaction.htm">Life of a Transaction</a>
            <p></p>
            <h5>Try Libra Core </h5><a href="my-first-transaction.htm">My First Transaction</a><a
              href="move-overview.htm">Getting Started With Move</a>
          </div>
          <div class="footerSection">
            <h5>Policies</h5><a href="privacy-policy.htm">Privacy Policy</a><a href="terms-of-use.htm">Terms of Use</a><a
              href="cookies-policy.htm">Cookies Policy</a><a href="code-of-conduct.htm">Code of Conduct</a>
            <p></p>
            <h5>Community</h5><a href="https://community.libra.org/">Developer Forum</a><a
              href="https://developers.libra.org/newsletter_form">Newsletter</a>
          </div>
          <div class="footerSection">
            <h5>Libra开发者社区</h5>
            <img style="width:150px" src='qr_violas.png'>
            <h5>备注”Libra“加群<h5>
          </div>
        </section>
        <section class="copyright"> © Violas Association</section>
      </footer>
  </div>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
  <script>
    document.addEventListener('keyup', function (e) {
      if (e.target !== document.body) {
        return;
      }
      // keyCode for '/' (slash)
      if (e.keyCode === 191) {
        const search = document.getElementById('search_input_react');
        search && search.focus();
      }
    });
  </script>
  <script>
    var search = docsearch({

      apiKey: '0d48ee629d39ddc4916eeef7755a0c4c',
      indexName: 'libra',
      inputSelector: '#search_input_react'
    });
  </script>
</body>

</html>