<!DOCTYPE html>
<html lang="en">

<head>
  <meta charSet="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Bytecode Verifier · Libra</title>
  <meta name="viewport" content="width=device-width" />
  <meta name="generator" content="Docusaurus" />
  <meta name="description" content="## Overview" />
  <meta name="docsearch:language" content="en" />
  <meta property="og:title" content="Bytecode Verifier · Libra" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://developers.libra.org/" />
  <meta property="og:description" content="## Overview" />
  <meta property="og:image" content="https://developers.libra.org/img/libra.png" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:image" content="https://developers.libra.org/img/libra.png" />
  <link rel="shortcut icon" href="libra.ico" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" />
  <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Libra Blog ATOM Feed" />
  <link rel="alternate" type="application/rss+xml" href="feed.xml" title="Libra Blog RSS Feed" />
  <script type="text/javascript" src="buttons.js"></script>
  <script type="text/javascript" src="code_block_buttons.js"></script>
  <script type="text/javascript" src="cookie_banner.js"></script>
  <script type="text/javascript" src="disable_adblock.js"></script>
  <script type="text/javascript" src="segment.analytics.min.js"></script>
  <script type="text/javascript" src="segment.js"></script>
  <script type="text/javascript" src="clipboardjs.2.0.0.min.js"></script>
  <script type="text/javascript" src="forms.js"></script>
  <script src="scrollSpy.js"></script>
  <link rel="stylesheet" href="main.css" />
  <script src="codetabs.js"></script>
</head>

<body class="sideNavVisible separateOnPageNav">
  <div class="fixedHeaderContainer">
    <div class="headerWrapper wrapper">
      <header><a href="https://developers.libra.org/"><img class="logo" src="libra-nav-logo.png" alt="Libra" />
          <h2 class="headerTitleWithLogo">Libra</h2>
        </a>
        <div class="navigationWrapper navigationSlider">
          <nav class="slidingNav">
            <ul class="nav-site nav-site-internal">
              <li class=""><a href="https://violas.io/">Home</a></li>
              <li class="siteNavGroupActive"><a href="welcome-to-libra.htm" target="_self">Documentation</a></li>
              <li class=""><a href="https://community.libra.org" target="_self">Community</a></li>
              <li class=""><a href="blog_2.html" target="_self">Libra Blog</a></li>
              <li class=""><a href="https://libra.org" target="_self">libra.org</a></li>
              <li class=""><a href="https://github.com/libra/libra" target="_self">Libra GitHub</a></li>
              <li class=""><a href="../lib_doc_en2cn/bytecode-verifier.htm" target="_self">中/EN</a></li>
              <li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react"
                  placeholder="Search" title="Search" /></li>
            </ul>
          </nav>
        </div>
      </header>
    </div>
  </div>
  <div class="navPusher">
    <div class="docMainWrapper wrapper">
      <div class="docsNavContainer" id="docsNav">
        <nav class="toc">
          <div class="toggleNav">
            <section class="navWrapper wrapper">
              <div class="navBreadcrumb wrapper">
                <div class="navToggle" id="navToggler">
                  <div class="hamburger-menu">
                    <div class="line1"></div>
                    <div class="line2"></div>
                    <div class="line3"></div>
                  </div>
                </div>
                <h2><i>›</i><span>READMEs</span></h2>
                <div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div>
              </div>
              <div class="navGroups">
                <div class="navGroup">
                  <h3 class="navGroupCategoryTitle">Learn About Libra</h3>
                  <ul class="">
                    <li class="navListItem"><a class="navItem" href="welcome-to-libra.htm">Welcome</a></li>
                    <li class="navListItem"><a class="navItem" href="libra-protocol.htm">Libra Protocol: Key
                        Concepts</a></li>
                    <li class="navListItem"><a class="navItem" href="life-of-a-transaction.htm">Life of a
                        Transaction</a></li>
                    <div class="navGroup subNavGroup">
                      <h4 class="navGroupSubcategoryTitle">Technical Papers</h4>
                      <ul>
                        <li class="navListItem"><a class="navItem" href="the-libra-blockchain-paper.htm">The Libra
                            Blockchain</a></li>
                        <li class="navListItem"><a class="navItem" href="move-paper.htm">Move: A Language With
                            Programmable Resources</a></li>
                        <li class="navListItem"><a class="navItem" href="state-machine-replication-paper.htm">State
                            Machine Replication in the Libra Blockchain</a></li>
                      </ul>
                    </div>
                  </ul>
                </div>
                <div class="navGroup">
                  <h3 class="navGroupCategoryTitle">Try Libra Core</h3>
                  <ul class="">
                    <li class="navListItem"><a class="navItem" href="my-first-transaction.htm">My First Transaction</a>
                    </li>
                    <li class="navListItem"><a class="navItem" href="move-overview.htm">Getting Started With Move</a>
                    </li>
                    <li class="navListItem"><a class="navItem" href="run-local-network.htm">Run a Local Network</a></li>
                    <li class="navListItem"><a class="navItem" href="run-move-locally.htm">Run Move Programs Locally</a>
                    </li>
                  </ul>
                </div>
                <div class="navGroup">
                  <h3 class="navGroupCategoryTitle">Community</h3>
                  <ul class="">
                    <li class="navListItem"><a class="navItem" href="libra-open-source-paper.htm">Libra Open Source</a>
                    </li>
                    <li class="navListItem"><a class="navItem" href="contributing.htm">Contribution Guide</a></li>
                    <li class="navListItem"><a class="navItem" href="coding-guidelines.htm">Coding Guidelines</a></li>
                    <li class="navListItem"><a class="navItem" href="security.htm">Reporting Vulnerabilities</a></li>
                  </ul>
                </div>
                <div class="navGroup">
                  <h3 class="navGroupCategoryTitle">Libra Codebase</h3>
                  <ul class="">
                    <li class="navListItem"><a class="navItem" href="libra-core-overview.htm">Libra Core Overview</a>
                    </li>
                    <div class="navGroup subNavGroup">
                      <h4 class="navGroupSubcategoryTitle">READMEs</h4>
                      <ul>
                        <li class="navListItem"><a class="navItem" href="admission-control.htm">Admission Control</a>
                        </li>
                        <li class="navListItem navListItemActive"><a class="navItem"
                            href="bytecode-verifier.htm">Bytecode Verifier</a></li>
                        <li class="navListItem"><a class="navItem" href="consensus.htm">Consensus</a></li>
                        <li class="navListItem"><a class="navItem" href="crypto.htm">Crypto</a></li>
                        <li class="navListItem"><a class="navItem" href="execution.htm">Execution</a></li>
                        <li class="navListItem"><a class="navItem" href="mempool.htm">Mempool</a></li>
                        <li class="navListItem"><a class="navItem" href="ir-to-bytecode.htm">Move IR Compiler</a></li>
                        <li class="navListItem"><a class="navItem" href="move-language.htm">Move Language</a></li>
                        <li class="navListItem"><a class="navItem" href="network.htm">Network</a></li>
                        <li class="navListItem"><a class="navItem" href="storage.htm">Storage</a></li>
                        <li class="navListItem"><a class="navItem" href="vm.htm">Virtual Machine</a></li>
                      </ul>
                    </div>
                  </ul>
                </div>
                <div class="navGroup">
                  <h3 class="navGroupCategoryTitle">Reference</h3>
                  <ul class="">
                    <li class="navListItem"><a class="navItem" href="libra-cli.htm">Libra CLI</a></li>
                    <li class="navListItem"><a class="navItem" href="glossary.htm">Glossary</a></li>
                  </ul>
                </div>
              </div>
            </section>
          </div>
          <script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory) {
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')) {
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function () {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function () {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function (event) {
                var el = event.target;
                while (el !== headings) {
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else {
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function (event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
          </script>
        </nav>
      </div>
      <div class="container mainContainer">
        <div class="wrapper">
          <div class="post">
            <header class="postHeader"><a class="edit-page-link button"
                href="https://github.com/libra/libra/edit/master/language/bytecode_verifier/README.md" target="_blank"
                rel="noreferrer noopener">Edit</a>
              <h1 class="postHeaderTitle">Bytecode Verifier</h1>
            </header>
            <article>
              <div><span>
                  <h2><a class="anchor" aria-hidden="true" id="overview"></a><a href="bytecode-verifier.htm#overview"
                      aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16"
                        version="1.1" viewBox="0 0 16 16" width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>Overview</h2>
                  <p>The bytecode verifier contains a static analysis tool for rejecting invalid Move bytecode. It
                    checks the safety of stack usage, types, resources, and references.</p>
                  <p>The body of each function in a compiled module is verified separately while trusting the
                    correctness of function signatures in the module. Checking that each function signature matches its
                    definition is a separate responsibility. The body of a function is a sequence of bytecode
                    instructions. This instruction sequence is checked in several phases described below.</p>
                  <h2><a class="anchor" aria-hidden="true" id="cfg-construction"></a><a
                      href="bytecode-verifier.htm#cfg-construction" aria-hidden="true" class="hash-link"><svg
                        class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16"
                        width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>CFG Construction</h2>
                  <p>A control-flow graph is constructed by decomposing the instruction sequence into a collection of
                    basic blocks. Each basic block contains a contiguous sequence of instructions; the set of all
                    instructions is partitioned among the blocks. Each block ends with a branch or return instruction.
                    The decomposition into blocks guarantees that branch targets land only at the beginning of some
                    block. The decomposition also attempts to ensure that the generated blocks are maximal. However, the
                    soundness of the analysis does not depend on maximality.</p>
                  <h2><a class="anchor" aria-hidden="true" id="stack-safety"></a><a
                      href="bytecode-verifier.htm#stack-safety" aria-hidden="true" class="hash-link"><svg
                        class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16"
                        width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>Stack Safety</h2>
                  <p>The execution of a block happens in the context of a stack and an array of local variables. The
                    parameters of the function are a prefix of the array of local variables. Arguments and return values
                    are passed across function calls via the stack. When a function starts executing, its arguments are
                    already loaded into its parameters. Suppose the stack height is <em>n</em> when a function starts
                    executing; then valid bytecode must enforce the invariant that when execution lands at the beginning
                    of a basic block, the stack height is <em>n</em>. Furthermore, at a return instruction, the stack
                    height must be <em>n</em>+<em>k</em> where <em>k</em>, s.t. <em>k</em>&gt;=0 is the number of return
                    values. The first phase of the analysis checks that this invariant is maintained by analyzing each
                    block separately, calculating the effect of each instruction in the block on the stack height,
                    checking that the height does not go below <em>n</em>, and that is left either at <em>n</em> or
                    <em>n</em>+<em>k</em> (depending on the final instruction of the block and the return type of the
                    function) at the end of the block.</p>
                  <h2><a class="anchor" aria-hidden="true" id="type-safety"></a><a
                      href="bytecode-verifier.htm#type-safety" aria-hidden="true" class="hash-link"><svg
                        class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16"
                        width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>Type Safety</h2>
                  <p>The second phase of the analysis checks that each operation, primitive or defined function, is
                    invoked with arguments of appropriate types. The operands of an operation are values located either
                    in a local variable or on the stack. The types of local variables of a function are already provided
                    in the bytecode. However, the types of stack values are inferred. This inference and the type
                    checking of each operation can be done separately for each block. Since the stack height at the
                    beginning of each block is <em>n</em> and does not go below <em>n</em> during the execution of the
                    block, we only need to model the suffix of the stack starting at <em>n</em> for type checking the
                    block instructions. We model this suffix using a stack of types on which types are pushed and popped
                    as the instruction stream in a block is processed. Only the type stack and the statically-known
                    types of local variables are needed to type check each instruction.</p>
                  <h2><a class="anchor" aria-hidden="true" id="resource-safety"></a><a
                      href="bytecode-verifier.htm#resource-safety" aria-hidden="true" class="hash-link"><svg
                        class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16"
                        width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>Resource Safety</h2>
                  <p>Resources represent the assets of the blockchain. As such, there are certain restrictions on these
                    types that do not apply to normal values. Intuitively, resource values cannot be copied and must be
                    used by the end of the transaction (this means that they are moved to global storage or destroyed).
                    Concretely, the following restrictions apply:</p>
                  <ul>
                    <li><code>CopyLoc</code> and <code>StLoc</code> require that the type of local is not of resource
                      kind.</li>
                    <li><code>WriteRef</code>, <code>Eq</code>, and <code>Neq</code> require that the type of the
                      reference is not of resource kind.</li>
                    <li>At the end of a function (when <code>Ret</code> is reached), no local whose type is of resource
                      kind must be empty, i.e., the value must have been moved out of the local.</li>
                  </ul>
                  <p>As mentioned above, this last rule around <code>Ret</code> implies that the resource <em>must</em>
                    have been either:</p>
                  <ul>
                    <li>Moved to global storage via <code>MoveToSender</code>.</li>
                    <li>Destroyed via <code>Unpack</code>.</li>
                  </ul>
                  <p>Both <code>MoveToSender</code> and <code>Unpack</code> are internal to the module in which the
                    resource is declared.</p>
                  <h2><a class="anchor" aria-hidden="true" id="reference-safety"></a><a
                      href="bytecode-verifier.htm#reference-safety" aria-hidden="true" class="hash-link"><svg
                        class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16"
                        width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>Reference Safety</h2>
                  <p>References are first-class in the bytecode language. Fresh references become available to a
                    function in several ways:</p>
                  <ul>
                    <li>Inputing parameters.</li>
                    <li>Taking the address of the value in a local variable.</li>
                    <li>Taking the address of the globally published value in an address.</li>
                    <li>Taking the address of a field from a reference to the containing struct.</li>
                    <li>Returning value from a function.</li>
                  </ul>
                  <p>The goal of reference safety checking is to ensure that there are no dangling references. Here are
                    some examples of dangling references:</p>
                  <ul>
                    <li>Local variable <code>y</code> contains a reference to the value in a local variable
                      <code>x</code>; <code>x</code> is then moved.</li>
                    <li>Local variable <code>y</code> contains a reference to the value in a local variable
                      <code>x</code>; <code>x</code> is then bound to a new value.</li>
                    <li>Reference is taken to a local variable that has not been initialized.</li>
                    <li>Reference to a value in a local variable is returned from a function.</li>
                    <li>Reference <code>r</code> is taken to a globally published value <code>v</code>; <code>v</code>
                      is then unpublished.</li>
                  </ul>
                  <p>References can be either exclusive or shared; the latter allow read-only access. A secondary goal
                    of reference safety checking is to ensure that in the execution context of the bytecode program —
                    including the entire evaluation stack and all function frames — if there are two distinct storage
                    locations containing references <code>r1</code> and <code>r2</code> such that <code>r2</code>
                    extends <code>r1</code>, then both of the following conditions hold:</p>
                  <ul>
                    <li>If <code>r1</code> is tagged as exclusive, then it must be inactive, i.e. it is impossible to
                      reach a control location where <code>r1</code> is dereferenced or mutated.</li>
                    <li>If <code>r1</code> is shared, then <code>r2</code> is shared.</li>
                  </ul>
                  <p>The two conditions above establish the property of referential transparency, important for scalable
                    program verification, which looks roughly as follows: consider the piece of code
                    <code>v1 = *r; S; v2 = *r</code>, where <code>S</code> is an arbitrary computation that does not
                    perform any write through the syntactic reference <code>r</code> (and no writes to any
                    <code>r'</code> that extends <code>r</code>). Then <code>v1 == v2</code>.</p>
                  <h3><a class="anchor" aria-hidden="true" id="analysis-setup"></a><a
                      href="bytecode-verifier.htm#analysis-setup" aria-hidden="true" class="hash-link"><svg
                        class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16"
                        width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>Analysis Setup</h3>
                  <p>The reference safety analysis is set up as a flow analysis (or abstract interpretation). An
                    abstract state is defined for abstractly executing the code of a basic block. A map is maintained
                    from basic blocks to abstract states. Given an abstract state <em>S</em> at the beginning of a basic
                    block <em>B</em>, the abstract execution of <em>B</em> results in state <em>S'</em>. This state
                    <em>S'</em> is propagated to all successors of <em>B</em> and recorded in the map. If a state
                    already existed for a block, the freshly propagated state is “joined” with the existing state. If
                    the join fails an error is reported. If the join succeeds but the abstract state remains unchanged,
                    no further propagation is done. Otherwise, the state is updated and propagated again through the
                    block. An error may also be reported when an instruction is processed during the propagation of
                    abstract state through a block.</p>
                  <h3><a class="anchor" aria-hidden="true" id="abstract-state"></a><a
                      href="bytecode-verifier.htm#abstract-state" aria-hidden="true" class="hash-link"><svg
                        class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16"
                        width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>Abstract State</h3>
                  <p>The abstract state has three components:</p>
                  <ul>
                    <li>A partial map from locals to abstract values. Locals that are not in the domain of this map are
                      unavailable. Availability is a generalization of the concept of being initialized. A local
                      variable may become unavailable subsequent to initialization as a result of being moved. An
                      abstract value is either <em>Reference</em>(<em>n</em>) (for variables of reference type) or
                      <em>Value</em>(<em>ns</em>) (for variables of value type), where <em>n</em> is a nonce and
                      <em>ns</em> is a set of nonces. A nonce is a constant used to represent a reference. Let
                      <em>Nonce</em> represent the set of all nonces. If a local variable <em>l</em> is mapped to
                      <em>Value</em>(<em>ns</em>), it means that there are outstanding borrowed references pointing into
                      the value stored in <em>l</em>. For each member <em>n</em> of <em>ns</em>, there must be a local
                      variable <em>l</em> mapped to <em>Reference</em>(<em>n</em>). If a local variable <em>x</em> is
                      mapped to <em>Reference</em>(<em>n</em>) and there are local variables <em>y</em> and <em>z</em>
                      mapped to <em>Value</em>(<em>ns1</em>) and <em>Value</em>(<em>ns2</em>) respectively, then it is
                      possible that <em>n</em> is a member of both <em>ns1</em> and <em>ns2</em>. This simply means that
                      the analysis is lossy. The special case when <em>l</em> is mapped to <em>Value</em>({}) means that
                      there are no borrowed references to <em>l</em>, and, therefore, <em>l</em> may be destroyed or
                      moved.</li>
                    <li>The partial map from locals to abstract values is not enough by itself to check bytecode
                      programs because values manipulated by the bytecode can be large nested structures with references
                      pointing into the middle. A reference pointing into the middle of a value could be extended to
                      produce another reference. Some extensions should be allowed but others should not. To keep track
                      of relative extensions among references, the abstract state has a second component. This component
                      is a map from nonces to one of the following two kinds of borrowed information:</li>
                    <li>A set of nonces.</li>
                    <li>A map from fields to sets of nonces.</li>
                  </ul>
                  <p>The current implementation stores this information as two separate maps with disjointed domains:
                  </p>
                  <ul>
                    <li><em>borrowed_by</em> maps from <em>Nonce</em> to <em>Set</em>&lt;<em>Nonce</em>&gt;.</li>
                    <li><em>fields_borrowed_by</em> maps from <em>Nonce</em> to <em>Map</em>&lt;<em>Field</em>,
                      <em>Set</em>&lt;<em>Nonce</em>&gt;&gt;.
                      <ul>
                        <li>If <em>n2</em> in <em>borrowed_by</em>[<em>n1</em>], then it means that the reference
                          represented by <em>n2</em> is an extension of the reference represented by <em>n1</em>.</li>
                        <li>If <em>n2</em> in <em>fields_borrowed_by</em>[<em>n1</em>][<em>f</em>], it means that the
                          reference represented by <em>n2</em> is an extension of the <em>f</em>-extension of the
                          reference represented by <em>n1</em>. Based on this intuition, it is a sound overapproximation
                          to move a nonce <em>n</em> from the domain of <em>fields_borrowed_by</em> to the domain of
                          <em>borrowed_by</em> by taking the union of all nonce sets corresponding to all fields in the
                          domain of <em>fields_borrowed_by</em>[<em>n</em>].</li>
                      </ul>
                    </li>
                    <li>To propagate an abstract state across the instructions in a block, the values and references on
                      the stack must also be modeled. We had earlier described how we model the usable stack suffix as a
                      stack of types. We now augment the contents of this stack to be a structure containing a type and
                      an abstract value. We maintain the invariant that non-reference values on the stack cannot have
                      pending borrows on them. Therefore, if there is an abstract value <em>Value</em>(<em>ns</em>) on
                      the stack, then <em>ns</em> is empty.</li>
                  </ul>
                  <h3><a class="anchor" aria-hidden="true" id="values-and-references"></a><a
                      href="bytecode-verifier.htm#values-and-references" aria-hidden="true" class="hash-link"><svg
                        class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16"
                        width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>Values and References</h3>
                  <p>Let us take a closer look at how values and references, shared and exclusive, are modeled.</p>
                  <ul>
                    <li>A non-reference value is modeled as <em>Value</em>(<em>ns</em>) where <em>ns</em> is a set of
                      nonces representing borrowed references. Destruction/move/copy of this value is deemed safe only
                      if <em>ns</em> is empty. Values on the stack trivially satisfy this property, but values in local
                      variables may not.</li>
                    <li>A reference is modeled as <em>Reference</em>(<em>n</em>), where <em>n</em> is a nonce. If the
                      reference is tagged as shared, then read access is always allowed and write access is never
                      allowed. If a reference <em>Reference</em>(<em>n</em>) is tagged exclusive, write access is
                      allowed only if <em>n</em> does not have a borrow, and read access is allowed if all nonces that
                      borrow from <em>n</em> reside in references that are tagged as shared. Furthermore, the rules for
                      constructing references guarantee that an extension of a reference tagged as shared must also be
                      tagged as shared. Together, these checks provide the property of referential transparency
                      mentioned earlier.</li>
                  </ul>
                  <p>At the moment, the bytecode language does not contain any direct constructors for shared
                    references. <code>BorrowLoc</code> and <code>BorrowGlobal</code> create exclusive references.
                    <code>BorrowField</code> creates a reference that inherits its tag from the source reference. Move
                    (when applied to a local variable containing a reference) moves the reference from a local variable
                    to the stack. <code>FreezeRef</code> is used to convert an existing exclusive reference to a shared
                    reference. In the future, we may add a version of <code>BorrowGlobal</code> that generates a shared
                    reference</p>
                  <p><strong>Errors.</strong> As mentioned earlier, an error is reported by the checker in one of the
                    following situations:</p>
                  <ul>
                    <li>An instruction cannot be proven to be safe during the propagation of the abstract state through
                      a block.</li>
                    <li>Join of abstract states propagated via different incoming edges into a block fails.</li>
                  </ul>
                  <p>Let us take a closer look at the second reason for error reporting above. Note that the stack of
                    type and abstract value pairs representing the usable stack suffix is empty at the beginning of a
                    block. So, the join occurs only over the abstract state representing the available local variables
                    and the borrow information. The join fails only in the situation when the set of available local
                    variables is different on the two edges. If the set of available variables is identical, the join
                    itself is straightforward — the borrow sets are joined point-wise. There are two subtleties worth
                    mentioning though:</p>
                  <ul>
                    <li>The set of nonces used in the abstract states along the two edges may not have any connection to
                      each other. Since the actual nonce values are immaterial, the nonces are canonically mapped to
                      fixed integers (indices of local variables containing the nonces) before performing the join.</li>
                    <li>During the join, if a nonce <em>n</em> is in the domain of borrowed_by on one side and in the
                      domain of fields_borrowed_by on the other side, <em>n</em> is moved from fields_borrowed_by to
                      borrowed_by before doing the join.</li>
                  </ul>
                  <h3><a class="anchor" aria-hidden="true" id="borrowing-references"></a><a
                      href="bytecode-verifier.htm#borrowing-references" aria-hidden="true" class="hash-link"><svg
                        class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16"
                        width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>Borrowing References</h3>
                  <p>Each of the reference constructors &mdash; <code>BorrowLoc</code>, <code>BorrowField</code>,
                    <code>BorrowGlobal</code>, <code>FreezeRef</code>, and <code>CopyLoc</code> &mdash; is modeled via
                    the generation of a fresh nonce. While <code>BorrowLoc</code> borrows from a value in a local
                    variable, <code>BorrowGlobal</code> borrows from the global pool of values.
                    <code>BorrowField</code>, <code>FreezeRef</code>, and <code>CopyLoc</code> (when applied to a local
                    containing a reference) borrow from the source reference. Since each fresh nonce is distinct from
                    all previously-generated nonces, the analysis maintains the invariant that all available local
                    variables and stack locations of reference type have distinct nonces representing their abstract
                    value. Another important invariant is that every nonce referred to in the borrow information must
                    reside in some abstract value representing a local variable or a stack location.</p>
                  <h3><a class="anchor" aria-hidden="true" id="releasing-references"></a><a
                      href="bytecode-verifier.htm#releasing-references" aria-hidden="true" class="hash-link"><svg
                        class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16"
                        width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>Releasing References.</h3>
                  <p>References, both global and local, are released by the <code>ReleaseRef</code> operation. It is an
                    error to return from a function with unreleased references in a local variable of the function. All
                    references must be explicitly released. Therefore, it is an error to overwrite an available
                    reference using the <code>StLoc</code> operation.</p>
                  <p>References are implicitly released when consumed by the operations <code>ReadRef</code>,
                    <code>WriteRef</code>, <code>Eq</code> and <code>Neq</code>.</p>
                  <h3><a class="anchor" aria-hidden="true" id="global-references"></a><a
                      href="bytecode-verifier.htm#global-references" aria-hidden="true" class="hash-link"><svg
                        class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16"
                        width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>Global References</h3>
                  <p>The safety of global references depends on a combination of static and dynamic analysis. The static
                    analysis does not distinguish between global and local references. But the dynamic analysis
                    distinguishes between them and performs reference counting on the global references as follows: the
                    bytecode interpreter maintains a map <code>M</code> from an address and fully-qualified resource
                    type pair to a union (Rust enum) comprising the following values:</p>
                  <ul>
                    <li><code>Empty</code></li>
                    <li><code>RefCount(n)</code> for some <code>n</code> &gt;= 0</li>
                  </ul>
                  <p>Extra state updates and checks are performed by the interpreter for the following operations. In
                    the code below, assert failure indicates a programmer error, and panic failure indicates internal
                    error in the interpreter.</p>
                  <pre><code class="hljs css language-text">MoveFrom<T>(addr) {
    assert M[addr, T] == RefCount(0);
    M[addr, T] := Empty;
}

MoveToSender<T>(addr) {
    assert M[addr, T] == Empty;
    M[addr, T] := RefCount(0);
}

BorrowGlobal<T>(addr) {
    if let RefCount(n) = M[addr, T] then {
        assert n == 0;
        M[addr, T] := RefCount(n+1);
    } else {
        assert false;
    }
}

CopyLoc(ref) {
    if let Global(addr, T) = ref {
        if let RefCount(n) = M[addr, T] then {
            assert n > 0;
            M[addr, T] := RefCount(n+1);
        } else {
            panic false;
        }
    }
}

ReleaseRef(ref) {
    if let Global(addr, T) = ref {
        if let RefCount(n) = M[addr, T] then {
            assert n > 0;
            M[addr, T] := RefCount(n-1);
        } else {
            panic false;
        }
    }
}
</code></pre>
                  <p>A subtle point not explicated by the rules above is that <code>BorrowField</code> and
                    <code>FreezeRef</code>, when applied to a global reference, leave the reference count unchanged.
                    This is because these instructions consume the reference at the top of the stack while producing an
                    extension of it at the top of the stack. Similarly, since <code>ReadRef</code>,
                    <code>WriteRef</code>, <code>Eq</code>, and <code>Neq</code> consume the reference at the top of the
                    stack, they will reduce the reference count by 1.</p>
                  <h2><a class="anchor" aria-hidden="true" id="how-is-this-module-organized"></a><a
                      href="bytecode-verifier.htm#how-is-this-module-organized" aria-hidden="true"
                      class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1"
                        viewBox="0 0 16 16" width="16">
                        <path fill-rule="evenodd"
                          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
                        </path>
                      </svg></a>How is this module organized?</h2>
                  <pre><code class="hljs css language-text">*
├── invalid_mutations  # Library used by proptests
├── src                # Core bytecode verifier files
├── tests              # Proptests
</code></pre>
                </span></div>
            </article>
          </div>
          <div class="docs-prevnext"><a class="docs-prev button" href="admission-control.htm"><span class="arrow-prev">←
              </span><span>Admission Control</span></a><a class="docs-next button"
              href="consensus.htm"><span>Consensus</span><span class="arrow-next"> →</span></a></div>
        </div>
      </div>
      <nav class="onPageNav">
        <ul class="toc-headings">
          <li><a href="bytecode-verifier.htm#overview">Overview</a></li>
          <li><a href="bytecode-verifier.htm#cfg-construction">CFG Construction</a></li>
          <li><a href="bytecode-verifier.htm#stack-safety">Stack Safety</a></li>
          <li><a href="bytecode-verifier.htm#type-safety">Type Safety</a></li>
          <li><a href="bytecode-verifier.htm#resource-safety">Resource Safety</a></li>
          <li><a href="bytecode-verifier.htm#reference-safety">Reference Safety</a>
            <ul class="toc-headings">
              <li><a href="bytecode-verifier.htm#analysis-setup">Analysis Setup</a></li>
              <li><a href="bytecode-verifier.htm#abstract-state">Abstract State</a></li>
              <li><a href="bytecode-verifier.htm#values-and-references">Values and References</a></li>
              <li><a href="bytecode-verifier.htm#borrowing-references">Borrowing References</a></li>
              <li><a href="bytecode-verifier.htm#releasing-references">Releasing References.</a></li>
              <li><a href="bytecode-verifier.htm#global-references">Global References</a></li>
            </ul>
          </li>
          <li><a href="bytecode-verifier.htm#how-is-this-module-organized">How is this module organized?</a></li>
        </ul>
      </nav>
    </div>
    <footer class="nav-footer" id="footer">
        <section class="sitemap"><a href="https://developers.libra.org/" class="nav-home"><img
              src="libra-logomark-white.png" alt="Libra" /></a>
          <div class="footerSection">
            <h5>Learn About Libra</h5><a href="welcome-to-libra.htm">Welcome to Libra</a><a
              href="libra-protocol.htm">Libra Protocol</a><a href="the-libra-blockchain-paper.htm">Libra Blockchain</a><a
              href="life-of-a-transaction.htm">Life of a Transaction</a>
            <p></p>
            <h5>Try Libra Core </h5><a href="my-first-transaction.htm">My First Transaction</a><a
              href="move-overview.htm">Getting Started With Move</a>
          </div>
          <div class="footerSection">
            <h5>Policies</h5><a href="privacy-policy.htm">Privacy Policy</a><a href="terms-of-use.htm">Terms of Use</a><a
              href="cookies-policy.htm">Cookies Policy</a><a href="code-of-conduct.htm">Code of Conduct</a>
            <p></p>
            <h5>Community</h5><a href="https://community.libra.org/">Developer Forum</a><a
              href="https://developers.libra.org/newsletter_form">Newsletter</a>
          </div>
          <div class="footerSection">
            <h5>Libra Developer Community</h5>
            <img style="width:300px" src='qr_violas.png'>
            <h5>Join us with scan and enter libra<h5>
          </div>
        </section>
        <section class="copyright"> © Violas Association</section>
      </footer>
  </div>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
  <script>
    document.addEventListener('keyup', function (e) {
      if (e.target !== document.body) {
        return;
      }
      // keyCode for '/' (slash)
      if (e.keyCode === 191) {
        const search = document.getElementById('search_input_react');
        search && search.focus();
      }
    });
  </script>
  <script>
    var search = docsearch({

      apiKey: '0d48ee629d39ddc4916eeef7755a0c4c',
      indexName: 'libra',
      inputSelector: '#search_input_react'
    });
  </script>
</body>

</html>